#' Create a SingleCellExperiment from a data directory
#'
#' Create a \linkS4class{SingleCellExperiment} object containing 
#' experimental data, sample metadata and general metadata from
#' a directory of files generated by Analytical Biosciences.
#'
#' @param dir String containing a path to a directory of files
#' generated by Analytical Biosciences.
#' @param relaxed Logical scalar indicating whether some of the
#' sanity checks should be relaxed.
#'
#' @return A \linkS4class{SingleCellExperiment} containing:
#' \itemize{
#' \item Experimental data in the \code{\link{assays}}, as obtained from \code{expressionMatrix.rds}.
#' \item Per-cell metadata in the \code{\link{colData}}, as obtained from \code{ontologyMapping.tsv} and \code{phenotype.tsv}.
#' \item Per-gene metadata in the \code{\link{rowData}}, as obtained from \code{geneID.tsv}
#' \item Dimensionality reduction results in \code{\link{reducedDims}}, as obtained from \code{phenotype.tsv}.
#' \item Study-wide metadta in the \code{\link{metadata}}, as obtained from \code{metadata.tsv}.
#' }
#' Any inconsistency in the shape of the data will lead to an error.
#'
#' @details
#' This ingests the data files to create a \linkS4class{SingleCellExperiment}
#' object that can be quickly queried to check the sanity of various inputs.
#' It will also serve as the basis of any upload to Genentech systems.
#' 
#' Setting \code{relaxed=TRUE} will not check for consistency between the column names of the matrix and the first field of the column metadata.
#' This will be set to \code{FALSE} in the future.
#'
#' @author Aaron Lun
#'
#' @examples
#' \dontrun{
#' sce <- createSCE("No_1/part_1")
#' }
#' @export
#' @importFrom SingleCellExperiment SingleCellExperiment
#' @importFrom utils read.delim
createSCE <- function(dir, relaxed=FALSE) {
    fnames <- list.files(dir, pattern="expressionMatrix.*\\.rds$")

    collected <- list()
    for (i in fnames) {
        mat <- readRDS(file.path(dir, i))
        nm <- sub("expressionMatrix_(.+)\\.rds", "\\1", i)
        collected[[nm]] <- mat
    }

    # Checking row/column consistency, if multiple matrices are present.
    all.cn <- unique(lapply(collected, colnames))
    all.rn <- unique(lapply(collected, rownames))
    stopifnot(length(all.rn)==1L && length(all.cn)==1L)

    rowData <- read.delim(file.path(dir, "geneID.tsv"), stringsAsFactors=FALSE)

    # Ignoring genes with no available names.
    # As is shown in No_22, there are some genes without names, 
    # and when we read the the matrix data in Python, the unnamed genes would be 
    # given names started with "Unamed: ", while in R they would become the pattern like "X12".
    is.geneName = !grepl("Unnamed: ",rowData[,1])
    # if rownames(mat) is of ensemblID format, then it should be the same with rowData[is.geneName,2]
    stopifnot(identical(rownames(mat)[is.geneName], rowData[is.geneName,1]) | 
              identical(rownames(mat)[is.geneName], rowData[is.geneName,2]))

    colData <- read.delim(file.path(dir, "phenotype.tsv"), stringsAsFactors=FALSE)
    if (!relaxed) {
        stopifnot(identical(all.cn[[1]], colData[,1]))
    }

    reducedDims <- list()
    is.tsne <- grepl("tSNE", colnames(colData))
    if (any(is.tsne)) {
        reducedDims[["tSNE"]] <- as.matrix(colData[,is.tsne])
    }
    is.umap <- grepl("UMAP", colnames(colData))
    if (any(is.umap)) {
        reducedDims[["UMAP"]] <- as.matrix(colData[,is.umap])
    }
    for (x in reducedDims) {
        stopifnot(is.numeric(x))
    }

    metadata <- read.delim(file.path(dir, "metadata.tsv"), stringsAsFactors=FALSE)
    metadata <- as.list(metadata)
    stopifnot(identical(as.integer(metadata$numberOfCells), ncol(collected[[1]])))
    stopifnot(identical(metadata$datasetID, paste0(basename(dirname(dir)), "_", basename(dir))))

    # Keeping it going if ontologyMapping data is not present.
    if ("ontologyMapping.tsv" %in% list.files(dir)) {
        metadata$ontology <- read.delim(file.path(dir, "ontologyMapping.tsv"), stringsAsFactors=FALSE)
        # Ignoring cells with no available cluster information
        # The cluster information of some cells are not given, so unique cluster names 
        # in colData may include "", which would not concur with that in the ontology data.
        is.Null = colData$clusterName == "" 
        stopifnot(identical(sort(unique(metadata$ontology$clusterName)), sort(unique(colData$clusterName[!is.Null]))))
        stopifnot(identical(sort(unique(metadata$ontology$clusterID)), sort(unique(colData$clusterID[!is.Null]))))
    }
       
    sce <- SingleCellExperiment(collected, rowData=rowData, colData=colData,
        reducedDims=reducedDims, metadata=metadata)
    sce
}
